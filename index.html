<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hourglass Pomodoro Widget</title>
  <style>
    /* ----- Reset / base ----- */
    html, body { height: 100%; }
    body {
      margin: 0;
      background: transparent; /* Notion embed-friendly */
      display: grid;
      place-items: center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      user-select: none;
    }

    /* Container with transparent background */
    .widget {
      position: relative;
      width: min(360px, 80vmin);
      aspect-ratio: 1/1.2;
      background: transparent;
      cursor: pointer;
      perspective: 1000px; /* for 3D x-rotation */
    }

    /* Volume control (50% opacity icon by default) */
    .volume {
      position: absolute;
      top: 8px; right: 8px;
      display: flex; align-items: center; gap: 6px;
      z-index: 5;
      opacity: 0.5; /* 50% transparency */
      transition: opacity .2s ease;
      background: rgba(0,0,0,0); /* invisible background */
    }
    .volume:hover { opacity: 1; }
    .volume button {
      width: 28px; height: 28px; border-radius: 6px;
      border: 1px solid rgba(60,60,60,.35);
      background: rgba(255,255,255,.08);
      backdrop-filter: blur(2px);
      display: grid; place-items: center;
      padding: 0; color: #5d6777; /* grey icon */
    }
    .volume input[type="range"]{
      width: 100px; height: 4px;
      -webkit-appearance: none; appearance: none;
      background: #d0d4db; border-radius: 999px;
      outline: none; border: none;
    }
    .volume input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #5d6777; border: 0; }
    .volume input[type="range"]::-moz-range-thumb      { width: 14px; height: 14px; border-radius: 50%; background: #5d6777; border: 0; }

    /* Hourglass card */
    .stage {
      position: absolute; inset: 0;
      display: grid; place-items: center;
      transform-style: preserve-3d;
      transition: transform .8s ease-in-out; /* flip time equals rotation time */
    }

    /* Color states */
    :root{
      --idle:#374152;     /* gray */
      --work:#16a34a;     /* green */
      --warn:#f59e0b;     /* yellow */
      --break:#ef4444;    /* red */
      --frame:#2b3545;    /* hourglass outline */
      --sand:#ffffff;     /* sand color (light) */
    }

    .hourglass {
      width: 85%;
      height: 85%;
      transform: translateZ(0);
    }

    /* Outline styling */
    .frame { fill: none; stroke: var(--frame); stroke-width: 22; stroke-linejoin: round; }

    /* Dynamic fills for sand */
    .sandTop, .sandBottom { fill: var(--sand); }

    /* Glow/inner color overlay for states */
    .tint { mix-blend-mode: multiply; opacity: 0.9; }

    /* Pause overlay text (hidden by default) */
    .paused-label {
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      font-size: 12px; letter-spacing: .08em; color: #8a94a6;
      text-transform: uppercase; opacity: 0; transition: opacity .2s ease;
    }
    .paused .paused-label { opacity: 1; }

    /* Invisible background to catch long-press comfortably */
    .hitbox { position: absolute; inset: 0; }
  </style>
</head>
<body>
  <div id="widget" class="widget" aria-label="Hourglass Pomodoro Widget" title="Click to start/pause • Hold 3s to reset">
    <!-- Volume -->
    <div class="volume" aria-label="Volume control">
      <button id="muteBtn" aria-label="Mute/unmute" title="Mute/unmute" type="button">
        <!-- speaker icon -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M3 10v4h4l5 4V6L7 10H3zm13.5 2c0-1.77-1.02-3.29-2.5-4.03v8.06c1.48-.74 2.5-2.26 2.5-4.03zM14 3.23v2.06c2.89 0.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-0.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
      </button>
      <input id="vol" type="range" min="0" max="1" step="0.01" value="0.7" aria-label="Volume" />
    </div>

    <!-- Scene -->
    <div id="stage" class="stage">
      <svg class="hourglass" viewBox="0 0 300 360" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <!-- Clip paths to constrain sand to top/bottom bulbs -->
        <defs>
          <clipPath id="clipTop">
            <!-- Top bulb shape -->
            <path d="M30 30 H270 A120 120 0 0 1 150 180 A120 120 0 0 1 30 30 Z"/>
          </clipPath>
          <clipPath id="clipBottom">
            <!-- Bottom bulb shape -->
            <path d="M30 330 H270 A120 120 0 0 0 150 180 A120 120 0 0 0 30 330 Z"/>
          </clipPath>
        </defs>

        <!-- Sand: top and bottom fill rectangles (heights animated in JS) -->
        <g clip-path="url(#clipTop)">
          <rect id="sandTop" class="sandTop" x="30" y="30" width="240" height="0" rx="8"/>
        </g>
        <g clip-path="url(#clipBottom)">
          <rect id="sandBottom" class="sandBottom" x="30" y="330" width="240" height="0" rx="8"/>
        </g>

        <!-- Neck stream (shows a trickle when running) -->
        <rect id="stream" x="145" y="172" width="10" height="16" fill="var(--sand)" rx="4" opacity="0"/>

        <!-- Tint overlay for state color (multiplied over sand/frame) -->
        <rect id="tint" class="tint" x="0" y="0" width="300" height="360" fill="var(--idle)" opacity="1"/>

        <!-- Outline/frame on top so it stays crisp -->
        <path class="frame" d="M20 20 H280 V40 H200 C190 40 185 45 178 52 C170 60 160 70 150 83 C140 70 130 60 122 52 C115 45 110 40 100 40 H20 Z
                                   M20 340 H280 V320 H200 C190 320 185 315 178 308 C170 300 160 290 150 277 C140 290 130 300 122 308 C115 315 110 320 100 320 H20 Z
                                   M120 170 C135 170 150 165 150 150 C150 135 165 130 180 130
                                   "/>
      </svg>
      <div class="paused-label" id="pausedLabel">Paused • hold 3s to reset</div>
      <div class="hitbox" id="hitbox"></div>
    </div>
  </div>

  <script>
    /*** CONFIG ***/
    const DUR_WORK = 25 * 60; // seconds
    const DUR_BREAK = 5 * 60;  // seconds
    const FLIP_MS = 800;      // x-rotation time (also the between-state gap)

    /*** STATE ***/
    const stage = document.getElementById('stage');
    const sandTop = document.getElementById('sandTop');
    const sandBottom = document.getElementById('sandBottom');
    const tint = document.getElementById('tint');
    const stream = document.getElementById('stream');
    const widgetEl = document.getElementById('widget');
    const pausedLabel = document.getElementById('pausedLabel');
    const hitbox = document.getElementById('hitbox');

    const vol = document.getElementById('vol');
    const muteBtn = document.getElementById('muteBtn');

    let muted = false;
    let currentPhase = 'idle'; // idle | work | work_warn | break
    let duration = DUR_WORK;   // seconds of current phase
    let startTs = 0;           // ms timestamp when (re)started
    let elapsedPaused = 0;     // ms accumulated before pause
    let ticking = false;       // running or paused
    let longPressTimer = null;

    // Dimensions (match clip rects)
    const TOP_MAX_H = 150;   // visual max sand height for top
    const BOTTOM_MAX_H = 150; // for bottom
    const TOP_Y = 30;
    const BOTTOM_Y = 330;

    // Initial sand all at bottom, idle gray
    setSand(0);
    setColor('idle');
    updateStream(false);
    stage.classList.add('paused');

    /*** AUDIO (Web Audio API) ***/
    let audioCtx = null;
    function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

    function beep(durationMs=500, frequency=880){
      if(muted) return;
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = frequency;
      const v = parseFloat(vol.value || '0.7');
      g.gain.value = v;
      o.connect(g).connect(audioCtx.destination);
      o.start();
      setTimeout(()=>{ o.stop(); }, durationMs);
    }

    async function doubleBeep(){
      beep(500);
      await wait(250 + 500); // 0.5s beep + 0.25s gap
      beep(500);
    }

    muteBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      muted = !muted;
      muteBtn.style.color = muted ? '#c7ccd6' : '#5d6777';
    });

    /*** INTERACTION ***/
    function wait(ms){ return new Promise(res=>setTimeout(res, ms)); }

    function flip(){
      // X-axis flip animation
      stage.style.transform = stage.style.transform.includes('rotateX(180deg)') ? 'rotateX(0deg)' : 'rotateX(180deg)';
      return wait(FLIP_MS);
    }

    function setColor(mode){
      let color = getComputedStyle(document.documentElement).getPropertyValue('--idle');
      if(mode==='work') color = getComputedStyle(document.documentElement).getPropertyValue('--work');
      if(mode==='work_warn') color = getComputedStyle(document.documentElement).getPropertyValue('--warn');
      if(mode==='break') color = getComputedStyle(document.documentElement).getPropertyValue('--break');
      tint.setAttribute('fill', color.trim());
    }

    function setSand(progress){
      // progress 0..1 of phase elapsed
      // top amount = 1-progress; bottom = progress
      const topH = TOP_MAX_H * (1 - progress);
      const bottomH = BOTTOM_MAX_H * progress;
      sandTop.setAttribute('y', TOP_Y + (TOP_MAX_H - topH));
      sandTop.setAttribute('height', Math.max(0, topH));
      sandBottom.setAttribute('y', BOTTOM_Y - bottomH);
      sandBottom.setAttribute('height', Math.max(0, bottomH));
    }

    function updateStream(active){ stream.style.opacity = active ? 1 : 0; }

    function now(){ return performance.now(); }

    function startPhase(phase){
      currentPhase = phase;
      duration = (phase==='break') ? DUR_BREAK : DUR_WORK;
      startTs = now();
      elapsedPaused = 0;
      ticking = true;
      stage.classList.remove('paused');
      updateStream(true);
      if(phase==='work') setColor('work');
      if(phase==='break') setColor('break');
      requestAnimationFrame(tick);
    }

    function pause(){
      ticking = false;
      elapsedPaused += now() - startTs;
      stage.classList.add('paused');
      updateStream(false);
      setColor('idle');
    }

    function reset(){
      ticking = false;
      currentPhase = 'idle';
      setSand(1); // all sand at bottom when idle display
      stage.classList.add('paused');
      updateStream(false);
      setColor('idle');
    }

    function resume(){
      startTs = now();
      ticking = true;
      stage.classList.remove('paused');
      updateStream(true);
      // Restore color based on remaining time
      if(currentPhase==='break') setColor('break');
      if(currentPhase==='work' || currentPhase==='work_warn') setColor(currentPhase);
      requestAnimationFrame(tick);
    }

    function remainingMs(){
      const elapsed = ticking ? (now() - startTs + elapsedPaused) : elapsedPaused;
      return Math.max(0, duration*1000 - elapsed);
    }

    // Manage long-press reset (3 seconds)
    widgetEl.addEventListener('mousedown', () => {
      longPressTimer = setTimeout(()=>{
        reset();
      }, 3000);
    });
    ['mouseup','mouseleave'].forEach(evt => widgetEl.addEventListener(evt, ()=>{
      if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; }
    }));

    // Click to start/pause
    widgetEl.addEventListener('click', (e)=>{
      // ignore clicks on volume children
      if(e.target.closest('.volume')) return;

      if(currentPhase==='idle'){
        // From idle, flip, turn green, and start work
        flip().then(()=>{
          setSand(0); // when flipped, all sand at top at t=0 (visually handled because we flip the whole scene)
          startPhase('work');
        });
        return;
      }
      if(ticking){
        pause();
      }else{
        resume();
      }
    });

    let warned = false;

    function tick(){
      if(!ticking) return;
      const rem = remainingMs();
      const progress = 1 - rem / (duration*1000);
      setSand(progress);

      if(currentPhase==='work' && rem <= 5*60*1000 && !warned){
        // Enter warning sub-state once at 5 minutes remaining
        warned = true;
        currentPhase = 'work_warn';
        setColor('work_warn');
        beep(500);
      }

      if(rem <= 0){
        onPhaseComplete();
        return;
      }
      requestAnimationFrame(tick);
    }

    async function onPhaseComplete(){
      ticking = false;
      updateStream(false);
      if(currentPhase==='work' || currentPhase==='work_warn'){
        warned = false;
        await doubleBeep();
        await flip();
        // Transition to 5-minute break (red)
        setSand(0); // visually, after flip, sand starts on top again
        startPhase('break');
      }else if(currentPhase==='break'){
        await flip();
        // Transition to 25-minute work (green)
        setSand(0);
        startPhase('work');
      }
    }

    // Accessibility: Space/Enter to toggle; Backspace to reset
    window.addEventListener('keydown', (e)=>{
      if(['Space','Enter'].includes(e.code)){
        e.preventDefault(); widgetEl.click();
      }
      if(e.code==='Backspace'){
        e.preventDefault(); reset();
      }
    });

    // Start in idle display: hourglass upright with sand at bottom
    // Ensure the stage is not rotated initially (so the first flip visually turns it over)
    stage.style.transform = 'rotateX(0deg)';
    setSand(1); // bottom full
  </script>
</body>
</html>
